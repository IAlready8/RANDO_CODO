#!/usr/bin/env python3
“””
Graphical User Interface for the Modular Knowledge System.
This module provides a GUI alternative to the CLI interface.
Optimized for performance, memory usage, and responsiveness.
“””
import os
import sys
import json
import threading
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
from tkinter.font import Font
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import networkx as nx
from pathlib import Path
import textwrap
import io
import contextlib
import time
import queue
import functools
import weakref

# Constants for UI configuration

PADDING = 10
BUTTON_WIDTH = 20
TEXT_WIDTH = 80
DEFAULT_FONT = (“Arial”, 10)
HEADER_FONT = (“Arial”, 16, “bold”)
SUBHEADER_FONT = (“Arial”, 12, “bold”)
BACKGROUND_COLOR = “#f5f5f5”

try:
from mks.core.system import ModularKnowledgeSystem
except ImportError:
print(“Error: Modular Knowledge System package not found.”)
print(“Please ensure the package is installed by running:”)
print(”  pip install -e .”)
sys.exit(1)

def performance_monitor(func):
“”“Decorator to monitor performance of functions.”””
@functools.wraps(func)
def wrapper(*args, **kwargs):
start_time = time.time()
result = func(*args, **kwargs)
end_time = time.time()
execution_time = end_time - start_time
if execution_time > 0.1:  # Only log operations that take more than 100ms
print(f”Performance: {func.**name**} took {execution_time:.4f} seconds”)
return result
return wrapper

class BufferedText:
“”“A buffer for text operations to minimize GUI updates.”””

```
def __init__(self, text_widget):
    self.text_widget = text_widget
    self.buffer = []

def insert(self, position, text, tag=None):
    self.buffer.append((position, text, tag))

def flush(self):
    """Apply all buffered operations at once to reduce GUI updates."""
    if not self.buffer:
        return
    
    self.text_widget.config(state=tk.NORMAL)
    for position, text, tag in self.buffer:
        if tag:
            self.text_widget.insert(position, text, tag)
        else:
            self.text_widget.insert(position, text)
    self.text_widget.see(tk.END)
    self.text_widget.config(state=tk.DISABLED)
    self.buffer.clear()
```

class ScrollableFrame(ttk.Frame):
“”“A scrollable frame widget with optimized canvas rendering.”””

```
def __init__(self, container, *args, **kwargs):
    super().__init__(container, *args, **kwargs)
    
    # Use double buffering to reduce flicker
    self.canvas = tk.Canvas(self, highlightthickness=0, doublebuffer=True)
    scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
    
    self.scrollable_frame = ttk.Frame(self.canvas)
    
    # Store callback reference to avoid garbage collection
    self._configure_callback = lambda e: self._on_frame_configure()
    self.scrollable_frame.bind("<Configure>", self._configure_callback)
    
    self._frame_id = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
    self.canvas.configure(yscrollcommand=scrollbar.set)
    
    # Use weights for better resizing behavior
    self.columnconfigure(0, weight=1)
    self.rowconfigure(0, weight=1)
    
    self.canvas.grid(row=0, column=0, sticky="nsew")
    scrollbar.grid(row=0, column=1, sticky="ns")
    
    # Mouse wheel scrolling with throttling
    self._last_scroll_time = 0
    self._scroll_throttle = 0.05  # seconds
    self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
    
    # Bind to window resizing for better layout
    self.canvas.bind("<Configure>", self._on_canvas_configure)

def _on_frame_configure(self):
    """Update the scrollregion to encompass the inner frame."""
    self.canvas.configure(scrollregion=self.canvas.bbox("all"))

def _on_canvas_configure(self, event):
    """Resize the inner frame to match the canvas."""
    # Adjust the width of the canvas window
    canvas_width = event.width
    self.canvas.itemconfig(self._frame_id, width=canvas_width)

def _on_mousewheel(self, event):
    """Handle mouse wheel scrolling with throttling."""
    current_time = time.time()
    if current_time - self._last_scroll_time < self._scroll_throttle:
        return
    
    self._last_scroll_time = current_time
    self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
```

class OutputRedirector:
“”“Redirect stdout to a tkinter Text widget with efficient buffering.”””

```
def __init__(self, text_widget, buffer_size=1024):
    self.text_widget = text_widget
    self.buffer = ""
    self.buffer_size = buffer_size
    self.update_queue = queue.Queue()
    
    # Start a timer to process the queue periodically
    self._schedule_update()

def write(self, string):
    """Buffer writes and process them in batches."""
    self.buffer += string
    if len(self.buffer) >= self.buffer_size or '\n' in string:
        self.update_queue.put(self.buffer)
        self.buffer = ""

def _schedule_update(self):
    """Process any queued updates and reschedule."""
    self._process_updates()
    # Schedule next update (40ms = ~25 fps, good for UI updates)
    if self.text_widget.winfo_exists():
        self.text_widget.after(40, self._schedule_update)

def _process_updates(self):
    """Process all pending updates from the queue."""
    try:
        # Process all available updates
        updates = []
        while not self.update_queue.empty():
            updates.append(self.update_queue.get_nowait())
            self.update_queue.task_done()
        
        if updates:
            combined_update = ''.join(updates)
            self.text_widget.config(state=tk.NORMAL)
            self.text_widget.insert(tk.END, combined_update)
            
            # Limit buffer size to prevent memory issues (keep last ~10K chars)
            if self.text_widget.index(tk.END) > "1000.0":
                self.text_widget.delete("1.0", "500.0")
            
            self.text_widget.see(tk.END)
            self.text_widget.config(state=tk.DISABLED)
    except Exception as e:
        # Silently handle errors during shutdown
        pass

def flush(self):
    """Flush the remaining buffer."""
    if self.buffer:
        self.update_queue.put(self.buffer)
        self.buffer = ""
```

class ThreadSafeCounter:
“”“Thread-safe counter for tracking operations.”””

```
def __init__(self):
    self.value = 0
    self._lock = threading.Lock()

def increment(self):
    with self._lock:
        self.value += 1
    return self.value

def decrement(self):
    with self._lock:
        self.value -= 1
    return self.value

def get(self):
    with self._lock:
        return self.value
```

class ThreadPool:
“”“Simple thread pool for background tasks.”””

```
def __init__(self, max_workers=4):
    self.tasks = queue.Queue()
    self.max_workers = max_workers
    self.workers = []
    self.running = True
    self.active_tasks = ThreadSafeCounter()
    
    # Start worker threads
    for _ in range(max_workers):
        worker = threading.Thread(target=self._worker_loop, daemon=True)
        worker.start()
        self.workers.append(worker)

def _worker_loop(self):
    """Worker thread loop to process tasks."""
    while self.running:
        try:
            task, args, kwargs, callback = self.tasks.get(timeout=0.5)
            self.active_tasks.increment()
            try:
                result = task(*args, **kwargs)
                if callback:
                    callback(result)
            except Exception as e:
                print(f"Error in thread pool task: {e}")
            finally:
                self.active_tasks.decrement()
                self.tasks.task_done()
        except queue.Empty:
            continue

def submit(self, task, callback=None, *args, **kwargs):
    """Submit a task to the thread pool."""
    if self.running:
        self.tasks.put((task, args, kwargs, callback))

def shutdown(self):
    """Shutdown the thread pool."""
    self.running = False
    for worker in self.workers:
        if worker.is_alive():
            worker.join(0.1)  # Give workers a chance to exit gracefully
```

class ModularKnowledgeSystemGUI(tk.Tk):
“”“Main GUI class for the Modular Knowledge System, optimized for performance.”””

```
def __init__(self):
    """Initialize the GUI with optimized components and lazy loading."""
    super().__init__()
    
    self.title("Modular Knowledge System")
    self.geometry("1200x800")
    self.minsize(800, 600)
    
    # Set up the thread pool for background tasks
    self.thread_pool = ThreadPool(max_workers=4)
    
    # Track active operations to prevent concurrent operations
    self._operations_counter = ThreadSafeCounter()
    
    # Setup UI style once instead of repeatedly
    self._setup_styles()
    
    # Instance variables with efficient memory usage
    self.system = None
    self.domains = []
    self.frameworks = []
    self.last_result = None
    self.output_dir = Path.cwd() / 'outputs'
    self.output_dir.mkdir(exist_ok=True)
    
    # Use weak references to allow garbage collection of large objects
    self._knowledge_graph_fig = None
    self._knowledge_graph_canvas = None
    
    # Setup the main container with proper weights for better resizing
    self.main_frame = ttk.Frame(self)
    self.main_frame.pack(fill=tk.BOTH, expand=True, padx=PADDING, pady=PADDING)
    
    # Create notebook with optimized tab creation
    self.notebook = ttk.Notebook(self.main_frame)
    self.notebook.pack(fill=tk.BOTH, expand=True)
    
    # Cache for tab widgets to avoid recreating them
    self._tab_frames = {}
    
    # Create initial tabs efficiently
    self._create_home_tab()
    
    # Status bar at the bottom
    self.status_var = tk.StringVar()
    self.status_var.set("Ready")
    self.status_bar = ttk.Label(
        self, 
        textvariable=self.status_var, 
        relief=tk.SUNKEN, 
        anchor=tk.W
    )
    self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    # Lazy load other tabs on first selection
    self.notebook.bind("<<NotebookTabChanged>>", self._on_tab_changed)
    
    # Set up event bindings for proper cleanup
    self.protocol("WM_DELETE_WINDOW", self._on_close)
    
    # Initialize system in a background thread
    self.after(100, self._initialize_system_threaded)

def _setup_styles(self):
    """Set up ttk styles once for better performance."""
    self.style = ttk.Style()
    
    # Configure styles only once
    self.style.configure("TFrame", background=BACKGROUND_COLOR)
    self.style.configure("TLabel", background=BACKGROUND_COLOR)
    self.style.configure("TButton", font=DEFAULT_FONT)
    self.style.configure("Header.TLabel", font=HEADER_FONT)
    self.style.configure("Subheader.TLabel", font=SUBHEADER_FONT)
    
    # Add padding to buttons for better usability
    self.style.configure("TButton", padding=5)
    
    # Optimize combobox rendering
    self.style.configure("TCombobox", padding=2)
    
    # Improve notebook appearance
    self.style.configure("TNotebook", background=BACKGROUND_COLOR)
    self.style.configure("TNotebook.Tab", padding=[10, 2])

def _on_tab_changed(self, event):
    """Lazy load tabs when first selected to improve startup time."""
    current_tab = self.notebook.index(self.notebook.select())
    tab_name = self.notebook.tab(current_tab, "text")
    
    # Initialize tabs only when they're first selected
    if tab_name == "Query" and "Query" not in self._tab_frames:
        self._create_query_tab()
    elif tab_name == "Domain-Specific" and "Domain-Specific" not in self._tab_frames:
        self._create_domain_tab()
    elif tab_name == "Framework-Specific" and "Framework-Specific" not in self._tab_frames:
        self._create_framework_tab()
    elif tab_name == "Visualization" and "Visualization" not in self._tab_frames:
        self._create_visualization_tab()
    elif tab_name == "Settings" and "Settings" not in self._tab_frames:
        self._create_settings_tab()

def _on_close(self):
    """Clean up resources before closing."""
    # Stop redirecting stdout
    if hasattr(self, "stdout_redirector"):
        sys.stdout = sys.__stdout__
    
    # Shutdown thread pool
    self.thread_pool.shutdown()
    
    # Allow matplotlib to clean up resources
    if self._knowledge_graph_fig is not None:
        plt.close(self._knowledge_graph_fig)
    
    # Destroy the window
    self.destroy()

def _create_home_tab(self):
    """Create the home tab with system information."""
    home_frame = ttk.Frame(self.notebook)
    self.notebook.add(home_frame, text="Home")
    self._tab_frames["Home"] = home_frame
    
    # Title and description
    title_label = ttk.Label(
        home_frame, 
        text="Modular Knowledge System", 
        font=HEADER_FONT,
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    description_label = ttk.Label(
        home_frame,
        text="A system that connects specialized knowledge with problem-solving frameworks",
        font=("Arial", 12),
        wraplength=600
    )
    description_label.pack(pady=(0, 20))
    
    # System status frame
    status_frame = ttk.LabelFrame(home_frame, text="System Status")
    status_frame.pack(fill=tk.X, padx=20, pady=10)
    
    self.system_status_var = tk.StringVar()
    self.system_status_var.set("Not initialized")
    system_status_label = ttk.Label(status_frame, textvariable=self.system_status_var)
    system_status_label.pack(pady=5, padx=5, anchor=tk.W)
    
    init_button = ttk.Button(
        status_frame, 
        text="Initialize System", 
        command=self._initialize_system_threaded
    )
    init_button.pack(pady=5, padx=5, anchor=tk.W)
    
    # Quick links frame
    links_frame = ttk.LabelFrame(home_frame, text="Quick Links")
    links_frame.pack(fill=tk.X, padx=20, pady=10)
    
    # Create buttons with consistent sizing for better UI
    for i, (text, tab_idx) in enumerate([
        ("New Query", 1), 
        ("Domain-Specific Query", 2), 
        ("Framework-Specific Query", 3),
        ("Knowledge Graph", 4)
    ]):
        button = ttk.Button(
            links_frame, 
            text=text, 
            command=lambda idx=tab_idx: self.notebook.select(idx),
            width=BUTTON_WIDTH
        )
        button.pack(pady=5, padx=5, side=tk.LEFT)
    
    # Launch CLI button
    cli_frame = ttk.LabelFrame(home_frame, text="Command Line Interface")
    cli_frame.pack(fill=tk.X, padx=20, pady=10)
    
    cli_desc_label = ttk.Label(
        cli_frame,
        text="Launch the command-line interface for text-based interaction.",
        wraplength=600
    )
    cli_desc_label.pack(pady=5, padx=5, anchor=tk.W)
    
    cli_button = ttk.Button(
        cli_frame, 
        text="Launch CLI", 
        command=self._launch_cli
    )
    cli_button.pack(pady=5, padx=5, anchor=tk.W)
    
    # Output console with efficient text buffer
    console_frame = ttk.LabelFrame(home_frame, text="Console Output")
    console_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    self.console_text = scrolledtext.ScrolledText(
        console_frame, 
        height=10, 
        wrap=tk.WORD,
        state=tk.DISABLED,
        background="#f8f8f8",  # Slightly different background for better readability
        font=("Consolas", 9)    # Monospaced font for console output
    )
    self.console_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Optimize text widget for performance
    self.console_text.config(maxundo=0, undo=False, autoseparators=False)
    
    # Redirect stdout to the console with optimized buffering
    self.stdout_redirector = OutputRedirector(self.console_text)
    sys.stdout = self.stdout_redirector

def _create_query_tab(self):
    """Create the query tab for general recommendations."""
    query_frame = ttk.Frame(self.notebook)
    self.notebook.add(query_frame, text="Query")
    self._tab_frames["Query"] = query_frame
    
    # Title and description
    title_label = ttk.Label(
        query_frame, 
        text="Get Recommendations", 
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    description_label = ttk.Label(
        query_frame,
        text="Enter your query to get a recommendation based on relevant knowledge and problem-solving frameworks.",
        wraplength=600
    )
    description_label.pack(pady=(0, 20))
    
    # Query input
    input_frame = ttk.Frame(query_frame)
    input_frame.pack(fill=tk.X, padx=20, pady=10)
    
    ttk.Label(input_frame, text="Query:").pack(anchor=tk.W)
    
    self.query_entry = ttk.Entry(input_frame, width=TEXT_WIDTH)
    self.query_entry.pack(fill=tk.X, pady=5)
    
    # Add keyboard shortcut for submission (Enter key)
    self.query_entry.bind("<Return>", lambda e: self._get_recommendation())
    
    # Examples dropdown
    examples_frame = ttk.Frame(input_frame)
    examples_frame.pack(fill=tk.X, pady=5)
    
    ttk.Label(examples_frame, text="Examples:").pack(side=tk.LEFT, padx=(0, 5))
    
    example_queries = [
        "How can I improve the user interface of my application?",
        "What's the best approach to designing a plumbing system?",
        "How should I organize my electrical wiring setup?",
        "What methodology should I use for my software project?",
        "How can I improve team collaboration on my project?"
    ]
    
    self.example_var = tk.StringVar()
    example_combo = ttk.Combobox(
        examples_frame, 
        textvariable=self.example_var, 
        values=example_queries,
        width=60
    )
    example_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    # Use lambda for cleaner event handling
    example_button = ttk.Button(
        examples_frame, 
        text="Use Example", 
        command=lambda: self._set_entry_text(self.query_entry, self.example_var.get())
    )
    example_button.pack(side=tk.LEFT, padx=5)
    
    # Buttons
    buttons_frame = ttk.Frame(input_frame)
    buttons_frame.pack(fill=tk.X, pady=10)
    
    get_button = ttk.Button(
        buttons_frame, 
        text="Get Recommendation", 
        command=self._get_recommendation
    )
    get_button.pack(side=tk.LEFT, padx=5)
    
    clear_button = ttk.Button(
        buttons_frame, 
        text="Clear", 
        command=lambda: (self.query_entry.delete(0, tk.END), self._clear_results())
    )
    clear_button.pack(side=tk.LEFT, padx=5)
    
    save_button = ttk.Button(
        buttons_frame, 
        text="Save Results", 
        command=self._save_results
    )
    save_button.pack(side=tk.LEFT, padx=5)
    
    # Results area with vertical split and optimized pane configuration
    results_paned = ttk.PanedWindow(query_frame, orient=tk.HORIZONTAL)
    results_paned.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    # Left pane - Summary
    left_frame = ttk.LabelFrame(results_paned, text="Summary")
    
    self.summary_text = scrolledtext.ScrolledText(
        left_frame, 
        wrap=tk.WORD,
        height=20,
        width=40,
        state=tk.DISABLED
    )
    self.summary_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Create buffered text handler for more efficient updates
    self.summary_buffer = BufferedText(self.summary_text)
    
    # Right pane - Detailed Steps
    right_frame = ttk.LabelFrame(results_paned, text="Solution Steps")
    
    self.steps_text = scrolledtext.ScrolledText(
        right_frame, 
        wrap=tk.WORD,
        height=20,
        width=60,
        state=tk.DISABLED
    )
    self.steps_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Create buffered text handler
    self.steps_buffer = BufferedText(self.steps_text)
    
    # Add frames to paned window with appropriate weights
    results_paned.add(left_frame, weight=1)
    results_paned.add(right_frame, weight=2)

def _create_domain_tab(self):
    """Create the domain-specific tab."""
    domain_frame = ttk.Frame(self.notebook)
    self.notebook.add(domain_frame, text="Domain-Specific")
    self._tab_frames["Domain-Specific"] = domain_frame
    
    # Title and description
    title_label = ttk.Label(
        domain_frame, 
        text="Domain-Specific Recommendations", 
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    description_label = ttk.Label(
        domain_frame,
        text="Get recommendations tailored to a specific knowledge domain.",
        wraplength=600
    )
    description_label.pack(pady=(0, 20))
    
    # Domain selection and query input
    input_frame = ttk.Frame(domain_frame)
    input_frame.pack(fill=tk.X, padx=20, pady=10)
    
    # Domain selection with proper layout
    domain_select_frame = ttk.Frame(input_frame)
    domain_select_frame.pack(fill=tk.X, pady=5)
    
    ttk.Label(domain_select_frame, text="Domain:").pack(side=tk.LEFT, padx=(0, 5))
    
    self.domain_var = tk.StringVar()
    self.domain_combo = ttk.Combobox(
        domain_select_frame, 
        textvariable=self.domain_var,
        state="readonly",
        width=40
    )
    self.domain_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    refresh_domains_button = ttk.Button(
        domain_select_frame, 
        text="Refresh Domains", 
        command=self._update_domain_list
    )
    refresh_domains_button.pack(side=tk.LEFT, padx=5)
    
    # Query input
    ttk.Label(input_frame, text="Query:").pack(anchor=tk.W, pady=(10, 0))
    
    self.domain_query_entry = ttk.Entry(input_frame, width=TEXT_WIDTH)
    self.domain_query_entry.pack(fill=tk.X, pady=5)
    
    # Add keyboard shortcut
    self.domain_query_entry.bind("<Return>", lambda e: self._get_domain_recommendation())
    
    # Buttons
    buttons_frame = ttk.Frame(input_frame)
    buttons_frame.pack(fill=tk.X, pady=10)
    
    get_button = ttk.Button(
        buttons_frame, 
        text="Get Domain-Specific Recommendation", 
        command=self._get_domain_recommendation
    )
    get_button.pack(side=tk.LEFT, padx=5)
    
    clear_button = ttk.Button(
        buttons_frame, 
        text="Clear", 
        command=lambda: (self.domain_query_entry.delete(0, tk.END), self._clear_results())
    )
    clear_button.pack(side=tk.LEFT, padx=5)
    
    save_button = ttk.Button(
        buttons_frame, 
        text="Save Results", 
        command=self._save_results
    )
    save_button.pack(side=tk.LEFT, padx=5)
    
    # Results area
    results_frame = ttk.LabelFrame(domain_frame, text="Results")
    results_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    # Results with optimized vertical split
    results_paned = ttk.PanedWindow(results_frame, orient=tk.HORIZONTAL)
    results_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Left pane - Domain Knowledge
    left_frame = ttk.LabelFrame(results_paned, text="Domain Knowledge")
    
    self.domain_knowledge_text = scrolledtext.ScrolledText(
        left_frame, 
        wrap=tk.WORD,
        height=20,
        width=40,
        state=tk.DISABLED
    )
    self.domain_knowledge_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Buffered text for domain knowledge
    self.domain_knowledge_buffer = BufferedText(self.domain_knowledge_text)
    
    # Right pane - Recommendations
    right_frame = ttk.LabelFrame(results_paned, text="Recommendations & Steps")
    
    self.domain_steps_text = scrolledtext.ScrolledText(
        right_frame, 
        wrap=tk.WORD,
        height=20,
        width=60,
        state=tk.DISABLED
    )
    self.domain_steps_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Buffered text for domain steps
    self.domain_steps_buffer = BufferedText(self.domain_steps_text)
    
    # Add panes with weights
    results_paned.add(left_frame, weight=1)
    results_paned.add(right_frame, weight=2)
    
    # If system is already initialized, update the domain list
    if self.system is not None:
        self._update_domain_list()

def _create_framework_tab(self):
    """Create the framework-specific tab."""
    framework_frame = ttk.Frame(self.notebook)
    self.notebook.add(framework_frame, text="Framework-Specific")
    self._tab_frames["Framework-Specific"] = framework_frame
    
    # Title and description
    title_label = ttk.Label(
        framework_frame, 
        text="Framework-Specific Recommendations", 
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    description_label = ttk.Label(
        framework_frame,
        text="Get recommendations using a specific problem-solving framework.",
        wraplength=600
    )
    description_label.pack(pady=(0, 20))
    
    # Framework selection and query input
    input_frame = ttk.Frame(framework_frame)
    input_frame.pack(fill=tk.X, padx=20, pady=10)
    
    # Framework selection
    framework_select_frame = ttk.Frame(input_frame)
    framework_select_frame.pack(fill=tk.X, pady=5)
    
    ttk.Label(framework_select_frame, text="Framework:").pack(side=tk.LEFT, padx=(0, 5))
    
    self.framework_var = tk.StringVar()
    self.framework_combo = ttk.Combobox(
        framework_select_frame, 
        textvariable=self.framework_var,
        state="readonly",
        width=40
    )
    self.framework_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    refresh_frameworks_button = ttk.Button(
        framework_select_frame, 
        text="Refresh Frameworks", 
        command=self._update_framework_list
    )
    refresh_frameworks_button.pack(side=tk.LEFT, padx=5)
    
    # Framework description (with scrollable text for long descriptions)
    desc_frame = ttk.Frame(input_frame)
    desc_frame.pack(fill=tk.X, pady=5)
    
    ttk.Label(desc_frame, text="Description:").pack(anchor=tk.W)
    
    self.framework_desc_text = scrolledtext.ScrolledText(
        desc_frame,
        height=3,
        wrap=tk.WORD,
        font=("Arial", 9),
        state=tk.DISABLED
    )
    self.framework_desc_text.pack(fill=tk.X, pady=5)
    
    # Update description when framework selected - use more efficient binding
    self.framework_combo.bind(
        "<<ComboboxSelected>>", 
        lambda e: self.after(10, self._update_framework_description)
    )
    
    # Query input
    ttk.Label(input_frame, text="Query:").pack(anchor=tk.W, pady=(10, 0))
    
    self.framework_query_entry = ttk.Entry(input_frame, width=TEXT_WIDTH)
    self.framework_query_entry.pack(fill=tk.X, pady=5)
    
    # Add keyboard shortcut
    self.framework_query_entry.bind("<Return>", lambda e: self._get_framework_recommendation())
    
    # Buttons
    buttons_frame = ttk.Frame(input_frame)
    buttons_frame.pack(fill=tk.X, pady=10)
    
    get_button = ttk.Button(
        buttons_frame, 
        text="Get Framework-Specific Recommendation", 
        command=self._get_framework_recommendation
    )
    get_button.pack(side=tk.LEFT, padx=5)
    
    clear_button = ttk.Button(
        buttons_frame, 
        text="Clear", 
        command=lambda: (self.framework_query_entry.delete(0, tk.END), self._clear_results())
    )
    clear_button.pack(side=tk.LEFT, padx=5)
    
    save_button = ttk.Button(
        buttons_frame, 
        text="Save Results", 
        command=self._save_results
    )
    save_button.pack(side=tk.LEFT, padx=5)
    
    # Results area with optimized scrolling
    results_frame = ttk.LabelFrame(framework_frame, text="Results")
    results_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    self.framework_results_text = scrolledtext.ScrolledText(
        results_frame, 
        wrap=tk.WORD,
        height=20,
        state=tk.DISABLED
    )
    self.framework_results_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
    
    # Buffered text for framework results
    self.framework_results_buffer = BufferedText(self.framework_results_text)
    
    # If system is already initialized, update the framework list
    if self.system is not None:
        self._update_framework_list()

def _create_visualization_tab(self):
    """Create the visualization tab for knowledge graph."""
    viz_frame = ttk.Frame(self.notebook)
    self.notebook.add(viz_frame, text="Visualization")
    self._tab_frames["Visualization"] = viz_frame
    
    # Title and description
    title_label = ttk.Label(
        viz_frame, 
        text="Knowledge Graph Visualization", 
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    description_label = ttk.Label(
        viz_frame,
        text="Visualize the relationships between different domains and concepts in the knowledge base.",
        wraplength=600
    )
    description_label.pack(pady=(0, 20))
    
    # Controls frame with expanded options for visualization
    controls_frame = ttk.Frame(viz_frame)
    controls_frame.pack(fill=tk.X, padx=20, pady=10)
    
    # Left side buttons
    left_buttons = ttk.Frame(controls_frame)
    left_buttons.pack(side=tk.LEFT, fill=tk.Y)
    
    generate_button = ttk.Button(
        left_buttons, 
        text="Generate Visualization", 
        command=self._generate_knowledge_graph
    )
    generate_button.pack(side=tk.LEFT, padx=5)
    
    save_viz_button = ttk.Button(
        left_buttons, 
        text="Save Visualization", 
        command=self._save_visualization
    )
    save_viz_button.pack(side=tk.LEFT, padx=5)
    
    # Visualization options
    viz_options = ttk.LabelFrame(controls_frame, text="Display Options")
    viz_options.pack(side=tk.RIGHT, fill=tk.Y, padx=5)
    
    # Node size slider
    self.node_size_var = tk.IntVar(value=500)
    ttk.Label(viz_options, text="Node Size:").pack(side=tk.LEFT, padx=5)
    node_size_scale = ttk.Scale(
        viz_options,
        from_=200,
        to=1000,
        orient=tk.HORIZONTAL,
        variable=self.node_size_var,
        length=150
    )
    node_size_scale.pack(side=tk.LEFT, padx=5)
    
    # Graph display frame with resizable canvas
    self.graph_frame = ttk.LabelFrame(viz_frame, text="Knowledge Graph")
    self.graph_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    # Placeholder text
    self.graph_placeholder = ttk.Label(
        self.graph_frame,
        text="Click 'Generate Visualization' to display the knowledge graph.",
        font=("Arial", 12),
        justify=tk.CENTER
    )
    self.graph_placeholder.pack(fill=tk.BOTH, expand=True)

def _create_settings_tab(self):
    """Create the settings tab with optimized widgets."""
    settings_frame = ttk.Frame(self.notebook)
    self.notebook.add(settings_frame, text="Settings")
    self._tab_frames["Settings"] = settings_frame
    
    # Title
    title_label = ttk.Label(
        settings_frame, 
        text="Settings & Configuration", 
        style="Header.TLabel"
    )
    title_label.pack(pady=(20, 5))
    
    # Create a notebook for settings categories
    settings_notebook = ttk.Notebook(settings_frame)
    settings_notebook.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
    
    # Output settings tab
    output_tab = ttk.Frame(settings_notebook)
    settings_notebook.add(output_tab, text="Output")
    
    # Output directory settings
    output_frame = ttk.LabelFrame(output_tab, text="Output Directory")
    output_frame.pack(fill=tk.X, padx=10, pady=10)
    
    output_path_frame = ttk.Frame(output_frame)
    output_path_frame.pack(fill=tk.X, pady=5, padx=5)
    
    ttk.Label(output_path_frame, text="Output Directory:").pack(side=tk.LEFT, padx=(0, 5))
    
    self.output_path_var = tk.StringVar()
    self.output_path_var.set(str(self.output_dir))
    
    output_path_entry = ttk.Entry(
        output_path_frame, 
        textvariable=self.output_path_var,
        width=60
    )
    output_path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    browse_button = ttk.Button(
        output_path_frame, 
        text="Browse...", 
        command=self._browse_output_dir
    )
    browse_button.pack(side=tk.LEFT, padx=5)
    
    apply_button = ttk.Button(
        output_frame, 
        text="Apply", 
        command=self._apply_output_dir
    )
    apply_button.pack(anchor=tk.W, pady=5, padx=5)
    
    # System tab
    system_tab = ttk.Frame(settings_notebook)
    settings_notebook.add(system_tab, text="System")
    
    # System actions
    system_frame = ttk.LabelFrame(system_tab, text="System Actions")
    system_frame.pack(fill=tk.X, padx=10, pady=10)
    
    reinit_button = ttk.Button(
        system_frame, 
        text="Reinitialize System", 
        command=self._initialize_system_threaded
    )
    reinit_button.pack(anchor=tk.W, pady=5, padx=5)
    
    # Performance optimization settings
    perf_frame = ttk.LabelFrame(system_tab, text="Performance")
    perf_frame.pack(fill=tk.X, padx=10, pady=10)
    
    # Cache control
    self.use_cache_var = tk.BooleanVar(value=True)
    cache_check = ttk.Checkbutton(
        perf_frame,
        text="Use result caching for faster responses",
        variable=self.use_cache_var
    )
    cache_check.pack(anchor=tk.W, pady=5, padx=5)
    
    # Thread pool size
    thread_frame = ttk.Frame(perf_frame)
    thread_frame.pack(fill=tk.X, pady=5, padx=5)
    
    ttk.Label(thread_frame, text="Worker Threads:").pack(side=tk.LEFT, padx=(0, 5))
    
    self.thread_count_var = tk.IntVar(value=4)
    thread_spin = ttk.Spinbox(
        thread_frame,
        from_=1,
        to=8,
        textvariable=self.thread_count_var,
        width=5
    )
    thread_spin.pack(side=tk.LEFT, padx=5)
    
    ttk.Label(thread_frame, 
             text="(Changes apply after restarting the application)").pack(side=tk.LEFT, padx=5)
    
    # About tab
    about_tab = ttk.Frame(settings_notebook)
    settings_notebook.add(about_tab, text="About")
    
    # About information
    about_frame = ttk.LabelFrame(about_tab, text="About")
    about_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    about_text = """Modular Knowledge System v0.1.0
```

A comprehensive system that connects specialized knowledge with
top general problem-solving frameworks to create tailored
context-specific guidance for specific challenges.

This application provides both a GUI and CLI interface.
“””

```
    about_label = ttk.Label(
        about_frame, 
        text=about_text,
        justify=tk.LEFT,
        wraplength=700
    )
    about_label.pack(pady=10, padx=10, anchor=tk.W)
    
    # Launch CLI button
    ttk.Button(
        about_frame, 
        text="Launch Command Line Interface", 
        command=self._launch_cli
    ).pack(pady=5, padx=10, anchor=tk.W)

@performance_monitor
def _initialize_system_threaded(self):
    """Initialize the system in a background thread with progress indication."""
    # Prevent multiple initialization attempts
    if self._operations_counter.get() > 0:
        return
        
    if self.system is not None:
        response = messagebox.askyesno(
            "Reinitialize System", 
            "System is already initialized. Reinitialize?"
        )
        if not response:
            return
    
    self.system_status_var.set("Initializing...")
    self.status_var.set("Initializing system...")
    
    # Disable navigation during initialization
    self.notebook.config(state=tk.DISABLED)
    
    # Increment operations counter
    self._operations_counter.increment()
    
    # Use thread pool for background work
    self.thread_pool.submit(
        self._initialize_system_task,
        self._initialize_system_callback
    )

def _initialize_system_task(self):
    """Task function for system initialization."""
    try:
        print("Initializing Modular Knowledge System...")
        system = ModularKnowledgeSystem()
        print("System initialized successfully!")
        return {"success": True, "system": system}
    except Exception as e:
        error_msg = f"Error initializing system: {str(e)}"
        print(error_msg)
        return {"success": False, "error": error_msg}

def _initialize_system_callback(self, result):
    """Callback function when initialization is complete."""
    if result["success"]:
        self.system = result["system"]
        
        # Update domain and framework lists
        self._update_domain_list()
        self._update_framework_list()
        
        # Update status
        self.system_status_var.set("Initialized")
        self.status_var.set("System initialized successfully")
    else:
        self.system_status_var.set("Initialization failed")
        self.status_var.set(result["error"])
        messagebox.showerror("Initialization Error", result["error"])
    
    # Re-enable navigation
    self.after(0, lambda: self.notebook.config(state=tk.NORMAL))
    
    # Decrement operations counter
    self._operations_counter.decrement()

@performance_monitor
def _update_domain_list(self):
    """Update the list of available domains with efficient caching."""
    if self.system is None:
        messagebox.showwarning("Not Initialized", "System is not initialized.")
        return
    
    # Show loading indicator
    prev_status = self.status_var.get()
    self.status_var.set("Retrieving domains...")
    
    try:
        # Get domains
        self.domains = self.system.get_all_domains()
        
        # Sort domains by name for better UX
        self.domains.sort(key=lambda d: d['name'])
        
        # Update domain dropdown
        domain_items = [f"{domain['name']} ({domain['id']})" for domain in self.domains]
        
        # Update UI if the combo exists
        if hasattr(self, 'domain_combo'):
            self.domain_combo['values'] = domain_items
            
            if domain_items:
                self.domain_combo.current(0)
        
        print(f"Retrieved {len(self.domains)} domains.")
        self.status_var.set(f"Retrieved {len(self.domains)} domains")
    except Exception as e:
        error_msg = f"Error retrieving domains: {str(e)}"
        print(error_msg)
        self.status_var.set(error_msg)
        messagebox.showerror("Error", error_msg)
    finally:
        # Restore status after a delay
        self.after(2000, lambda: self.status_var.set(prev_status))

@performance_monitor
def _update_framework_list(self):
    """Update the list of available frameworks with efficient caching."""
    if self.system is None:
        messagebox.showwarning("Not Initialized", "System is not initialized.")
        return
    
    # Show loading indicator
    prev_status = self.status_var.get()
    self.status_var.set("Retrieving frameworks...")
    
    try:
        # Get frameworks
        self.frameworks = self.system.get_all_frameworks()
        
        # Sort frameworks by name for better UX
        self.frameworks.sort(key=lambda f: f['name'])
        
        # Update framework dropdown if it exists
        if hasattr(self, 'framework_combo'):
            framework_items = [f"{framework['name']} ({framework['key']})" for framework in self.frameworks]
            self.framework_combo['values'] = framework_items
            
            if framework_items:
                self.framework_combo.current(0)
                self._update_framework_description()
        
        print(f"Retrieved {len(self.frameworks)} frameworks.")
        self.status_var.set(f"Retrieved {len(self.frameworks)} frameworks")
    except Exception as e:
        error_msg = f"Error retrieving frameworks: {str(e)}"
        print(error_msg)
        self.status_var.set(error_msg)
        messagebox.showerror("Error", error_msg)
    finally:
        # Restore status after a delay
        self.after(2000, lambda: self.status_var.set(prev_status))

def _update_framework_description(self):
    """Update the framework description when a framework is selected."""
    if not hasattr(self, 'framework_desc_text') or not self.frameworks:
        return
    
    try:
        selected_idx = self.framework_combo.current()
        if selected_idx >= 0:
            framework = self.frameworks[selected_idx]
            desc = framework.get('description', 'No description available.')
            steps = ", ".join(framework.get('steps', []))
            
            # Update text widget more efficiently
            self.framework_desc_text.config(state=tk.NORMAL)
            self.framework_desc_text.delete(1.0, tk.END)
            self.framework_desc_text.insert(tk.END, f"Description: {desc}\n\nSteps: {steps}")
            self.framework_desc_text.config(state=tk.DISABLED)
    except Exception as e:
        # Handle errors gracefully
        if hasattr(self, 'framework_desc_text'):
            self.framework_desc_text.config(state=tk.NORMAL)
            self.framework_desc_text.delete(1.0, tk.END)
            self.framework_desc_text.insert(tk.END, f"Error: {str(e)}")
            self.framework_desc_text.config(state=tk.DISABLED)

def _set_entry_text(self, entry, text):
    """Set entry text with efficient clearing."""
    entry.delete(0, tk.END)
    entry.insert(0, text)

@performance_monitor
def _get_recommendation(self):
    """Get a recommendation based on user query with progress indication."""
    if self._operations_counter.get() > 0:
        messagebox.showinfo("Operation in Progress", "Please wait for the current operation to complete.")
        return
        
    if self.system is None:
        messagebox.showwarning("Not Initialized", "System is not initialized.")
        return
    
    query = self.query_entry.get().strip()
    if not query:
        messagebox.showwarning("Empty Query", "Please enter a query.")
        return
    
    # Increment operations counter
    self._operations_counter.increment()
    
    # Update status
    self.status_var.set(f"Processing query: {query}")
    print(f"Getting recommendation for query: '{query}'")
    
    # Show cursor busy indicator
    self.config(cursor="wait")
    
    # Submit task to thread pool
    self.thread_pool.submit(
        lambda: self._get_recommendation_task(query),
        lambda result: self._recommendation_callback(result, "general")
    )

def _get_recommendation_task(self, query):
    """Background task to get recommendation."""
    try:
        result = self.system.get_recommendation(query)
        return {"success": True, "result": result}
    except Exception as e:
        error_msg = f"Error getting recommendation: {str(e)}"
        return {"success": False, "error": error_msg}

def _recommendation_callback(self, task_result, result_type):
    """Callback for recommendation tasks."""
    # Reset cursor
    self.config(cursor="")
    
    if task_result["success"]:
        result = task_result["result"]
        self.last_result = result
        
        # Display results based on type
        if result_type == "general":
            self._display_general_results(result)
        elif result_type == "domain":
            self._display_domain_results(result)
        elif result_type == "framework":
            self._display_framework_results(result)
        
        self.status_var.set("Recommendation generated successfully")
    else:
        error_msg = task_result["error"]
        print(error_msg)
        self.status_var.set(error_msg)
        messagebox.showerror("Error", error_msg)
    
    # Decrement operations counter
    self._operations_counter.decrement()

@performance_monitor
def _get_domain_recommendation(self):
    """Get a domain-specific recommendation with improved error handling."""
    if self._operations_counter.get() > 0:
        messagebox.showinfo("Operation in Progress", "Please wait for the current operation to complete.")
        return
        
    if self.system is None:
        messagebox.showwarning("Not Initialized", "System is not initialized.")
        return
    
    query = self.domain_query_entry.get().strip()
    if not query:
        messagebox.showwarning("Empty Query", "Please enter a query.")
        return
    
    selected_idx = self.domain_combo.current()
    if selected_idx < 0:
        messagebox.showwarning("No Domain Selected", "Please select a domain.")
        return
    
    domain_id = self.domains[selected_idx]['id']
    
    # Increment operations counter
    self._operations_counter.increment()
    
    # Update status
    self.status_var.set(f"Processing domain query: {query} for domain {domain_id}")
    print(f"Getting domain-specific recommendation for '{domain_id}': '{query}'")
    
    # Show cursor busy indicator
    self.config(cursor="wait")
    
    # Submit task to thread pool
    self.thread_pool.submit(
        lambda: self._get_domain_recommendation_task(query, domain_id),
        lambda result: self._recommendation_callback(result, "domain")
    )

def _get_domain_recommendation_task(self, query, domain_id):
    """Background task to get domain-specific recommendation."""
    try:
        result = self.system.get_domain_specific_recommendation(query, domain_id)
        return {"success": True, "result": result}
    except Exception as e:
        error_msg = f"Error getting domain recommendation: {str(e)}"
        return {"success": False, "error": error_msg}

@performance_monitor
def _get_framework_recommendation(self):
    """Get a framework-specific recommendation with improved error handling."""
    if self._operations_counter.get() > 0:
        messagebox.showinfo("Operation in Progress", "Please wait for the current operation to complete.")
        return
        
    if self.system is None:
        messagebox.showwarning("Not Initialized", "System is not initialized.")
        return
    
    query = self.framework_query_entry.get().strip()
    if not query:
        messagebox.showwarning("Empty Query", "Please enter a query.")
        return
    
    selected_idx = self.framework_combo.current()
    if selected_idx < 0:
        messagebox.showwarning("No Framework Selected", "Please select a framework.")
        return
    
    framework_key = self.frameworks[selected_idx]['key']
    
    # Increment operations counter
    self._operations_counter.increment()
    
    # Update status
    self.status_var.set(f"Processing framework query: {query} using {framework_key}")
    print(f"Getting framework-specific recommendation using '{framework_key}': '{query}'")
    
    # Show cursor busy indicator
    self.config(cursor="wait")
    
    # Submit task to thread pool
    self.thread_pool.submit(
        lambda: self._get_framework_recommendation_task(query, framework_key),
        lambda result: self._recommendation_callback(result, "framework")
    )

def _get_framework_recommendation_task(self, query, framework_key):
    """Background task to get framework-specific recommendation."""
    try:
        result = self.system.get_framework_specific_recommendation(query, framework_key)
        return {"success": True, "result": result}
    except Exception as e:
        error_msg = f"Error getting framework recommendation: {str(e)}"
        return {"success": False, "error": error_msg}

def _display_general_results(self, result):
    """Display general recommendation results with optimized text handling."""
    if 'error' in result:
        messagebox.showerror("Error", result['error'])
        return
    
    # Update summary text using buffer
    self.summary_buffer.insert(tk.END, f"Query: {result['query']}\n\n", "query")
    self.summary_buffer.insert(tk.END, "Knowledge Source:\n", "header")
    self.summary_buffer.insert(tk.END, f"{result['knowledge']['title']}\n\n")
    
    self.summary_buffer.insert(tk.END, "Framework:\n", "header")
    self.summary_buffer.insert(tk.END, f"{result['framework']['name']}\n\n")
    
    if 'similarity' in result['knowledge']:
        self.summary_buffer.insert(tk.END, f"Knowledge Relevance: {result['knowledge']['similarity']:.2f}\n")
    if 'similarity' in result['framework']:
        self.summary_buffer.insert(tk.END, f"Framework Relevance: {result['framework']['similarity']:.2f}\n\n")
    
    self.summary_buffer.insert(tk.END, "Recommendation:\n", "header")
    self.summary_buffer.insert(tk.END, f"{result['solution']['recommendation']}\n")
    
    # Apply all changes at once
    self.summary_text.config(state=tk.NORMAL)
    self.summary_text.delete(1.0, tk.END)
    self.summary_buffer.flush()
    
    # Tag formatting
    self.summary_text.tag_configure("header", font=("Arial", 11, "bold"))
    self.summary_text.tag_configure("query", font=("Arial", 12, "bold"))
    
    self.summary_text.config(state=tk.DISABLED)
    
    # Update steps text using buffer
    self.steps_buffer.insert(tk.END, "Solution Steps:\n\n", "header")
    
    for step in result['solution']['solution_steps']:
        self.steps_buffer.insert(tk.END, f"{step['step_number']}. {step['name']}\n", "step_name")
        self.steps_buffer.insert(tk.END, f"{step['description']}\n\n")
    
    # Apply all changes at once
    self.steps_text.config(state=tk.NORMAL)
    self.steps_text.delete(1.0, tk.END)
    self.steps_buffer.flush()
    
    # Tag formatting
    self.steps_text.tag_configure("header", font=("Arial", 12, "bold"))
    self.steps_text.tag_configure("step_name", font=("Arial", 11, "bold"))
    
    self.steps_text.config(state=tk.DISABLED)

def _display_domain_results(self, result):
    """Display domain-specific recommendation results with optimized text handling."""
    if 'error' in result:
        messagebox.showerror("Error", result['error'])
        return
    
    # Update knowledge text using buffer
    self.domain_knowledge_buffer.insert(tk.END, f"Query: {result['query']}\n\n", "query")
    self.domain_knowledge_buffer.insert(tk.END, f"Domain: {result['domain']}\n\n", "domain")
    
    self.domain_knowledge_buffer.insert(tk.END, "Knowledge Source:\n", "header")
    self.domain_knowledge_buffer.insert(tk.END, f"{result['knowledge']['title']}\n\n")
    
    if 'content' in result['knowledge']:
        self.domain_knowledge_buffer.insert(tk.END, "Content:\n", "header")
        self.domain_knowledge_buffer.insert(tk.END, f"{result['knowledge']['content']}\n\n")
    
    # Apply all changes at once
    self.domain_knowledge_text.config(state=tk.NORMAL)
    self.domain_knowledge_text.delete(1.0, tk.END)
    self.domain_knowledge_buffer.flush()
    
    # Tag formatting
    self.domain_knowledge_text.tag_configure("header", font=("Arial", 11, "bold"))
    self.domain_knowledge_text.tag_configure("query", font=("Arial", 12, "bold"))
    self.domain_knowledge_text.tag_configure("domain", font=("Arial", 12, "bold"))
    
    self.domain_knowledge_text.config(state=tk.DISABLED)
    
    # Update steps text using buffer
    self.domain_steps_buffer.insert(tk.END, f"Framework: {result['framework']['name']}\n\n", "framework")
    
    self.domain_steps_buffer.insert(tk.END, "Recommendation:\n", "header")
    self.domain_steps_buffer.insert(tk.END, f"{result['solution']['recommendation']}\n\n")
    
    self.domain_steps_buffer.insert(tk.END, "Solution Steps:\n\n", "header")
    
    for step in result['solution']['solution_steps']:
        self.domain_steps_buffer.insert(tk.END, f"{step['step_number']}. {step['name']}\n", "step_name")
        self.domain_steps_buffer.insert(tk.END, f"{step['description']}\n\n")
    
    # Apply all changes at once
    self.domain_steps_text.config(state=tk.NORMAL)
    self.domain_steps_text.delete(1.0, tk.END)
    self.domain_steps_buffer.flush()
    
    # Tag formatting
    self.domain_steps_text.tag_configure("header", font=("Arial", 11, "bold"))
    self.domain_steps_text.tag_configure("framework", font=("Arial", 12, "bold"))
    self.domain_steps_text.tag_configure("step_name", font=("Arial", 11, "bold"))
    
    self.domain_steps_text.config(state=tk.DISABLED)

def _display_framework_results(self, result):
    """Display framework-specific recommendation results with optimized text handling."""
    if 'error' in result:
        messagebox.showerror("Error", result['error'])
        return
    
    # Use buffer for efficient text updates
    buffer = self.framework_results_buffer
    
    buffer.insert(tk.END, f"Query: {result['query
```
